# Utilizer

Utilizer is a powerful and easy-to-use library for Bukkit/Spigot plugin development.

## Project Information

- Group ID: io.github.johnnypixelz
- Artifact ID: Utilizer
- Java Version: 17+
- Repository: https://github.com/JohnnyPixelz/Utilizer
- Maven Repository: https://repo.tzoni.me/releases

## Installation

### Maven
```xml
<repository>
    <id>tzoni-repo-releases</id>
    <url>https://repo.tzoni.me/releases</url>
</repository>

<dependency>
    <groupId>io.github.johnnypixelz</groupId>
    <artifactId>Utilizer</artifactId>
    <version>LATEST</version>
</dependency>
```

## Getting Started

### Plugin Setup

Extend `io.github.johnnypixelz.utilizer.plugin.UtilPlugin` instead of `JavaPlugin`:

```java
public class MyPlugin extends UtilPlugin {
    @Override
    public void onEnable() {
        // Your initialization code
    }
}
```

## Core Modules

### 1. Items (io.github.johnnypixelz.utilizer.itemstack.Items)

The Items system provides a fluent API for creating and editing ItemStacks without creating clones. All operations modify the underlying ItemStack directly.

```java
// Create a new item
ItemStack sword = Items.edit(Material.DIAMOND_SWORD)
    .setDisplayName("&bLegendary Sword")
    .setLore("&7A powerful weapon", "&7Forged in dragon fire")
    .addFlags(ItemFlag.HIDE_ENCHANTS)
    .glow()
    .getItem();

// Edit an existing item
Items.edit(existingItem)
    .setDisplayName("&eRenamed Item")
    .setAmount(64)
    .setGlow(true)
    .getItem();

// Add lore to existing item
Items.edit(item)
    .addLore("&7New lore line", "&7Another line")
    .getItem();

// Map placeholders in name and lore
Items.edit(item)
    .map("%player%", player.getName())
    .map("%level%", String.valueOf(level))
    .getItem();

// Get reference to underlying ItemStack (no clones created)
ItemStack reference = Items.edit(material).getItem();
```

**Key Methods:**
- `.setDisplayName(String)` - Set item name (auto-colors with &)
- `.setLore(String...)` - Set lore lines (replaces existing)
- `.addLore(String...)` - Add lore lines (appends to existing)
- `.setAmount(int)` - Set stack amount
- `.glow()` - Make item glow
- `.setGlow(boolean)` - Set glow state
- `.addFlags(ItemFlag...)` - Add item flags
- `.setFlags(ItemFlag...)` - Set flags (replaces all)
- `.clearFlags()` - Remove all flags
- `.map(String, String)` - Replace placeholder in name and lore
- `.mapName(String, String)` - Replace placeholder in name only
- `.mapLore(String, String)` - Replace placeholder in lore only
- `.setCustomModelData(int)` - Set custom model data
- `.setDurability(int)` - Set item durability/damage
- `.setType(Material)` - Change item material
- `.meta(Consumer<ItemMeta>)` - Direct meta access
- `.pdc(Consumer<PersistentDataContainer>)` - Access persistent data
- `.getItem()` - Get the ItemStack reference

**Key Features:**
- No clones - direct modification of ItemStack
- Chainable methods for clean code
- Automatic color parsing (& codes and hex)
- `getItem()` returns reference to the underlying ItemStack
- Support for conditional methods (e.g., `.setLoreIf(condition, lore)`)

### 2. Tasks (io.github.johnnypixelz.utilizer.tasks.Tasks)

Tasks replace the Bukkit Scheduler API with a cleaner, fluent interface for scheduling synchronous and asynchronous tasks.

```java
// Synchronous delayed task
Tasks.sync().delayed(() -> {
    // Your code here
}, 20L);  // Delay in ticks (20 ticks = 1 second)

// Asynchronous task
Tasks.async().run(() -> {
    // Async code here
});

// Repeating timer task
Tasks.sync().timer(() -> {
    // Repeating code
}, 20L);  // Runs every 20 ticks

// Delayed timer task
Tasks.sync().delayedTimer(() -> {
    // Repeating code with initial delay
}, 40L, 20L);  // 40 tick delay, then every 20 ticks

// Timed task with iterations
Tasks.sync().timed(() -> {
    // Runs exactly 5 times
}, 20L, 5L);  // Every 20 ticks, 5 iterations
```

**Key Methods:**
- `Tasks.sync()` - Get synchronous scheduler (main thread)
- `Tasks.async()` - Get asynchronous scheduler (separate thread)
- `.run(Runnable)` - Execute immediately
- `.delayed(Runnable, ticks)` - Execute after delay
- `.timer(Runnable, ticks)` - Repeat every X ticks
- `.delayedTimer(Runnable, delay, period)` - Delay then repeat
- `.timed(Runnable, period, iterations)` - Repeat with iteration limit
- `.delayedTimed(Runnable, delay, period, iterations)` - Delay, repeat with limit

### 3. Configs (io.github.johnnypixelz.utilizer.config.Configs)

Simplified configuration management with automatic file watching and reloading.

```java
// Load config on plugin startup (in onEnable)
@Override
public void onEnable() {
    // Load and watch all configs in resources folder
    Configs.load("config").watch();
    Configs.load("messages").watch();
    Configs.load("data").watch();
    // Note: Don't watch plugin.yml
}

// Access config values anywhere
String value = Configs.get("config").getString("path.to.key");
int number = Configs.get("config").getInt("some.number");
List<String> list = Configs.get("config").getStringList("my.list");

// Get with default value
String msg = Configs.get("messages").getString("welcome", "Default welcome!");

// Save config
Configs.load("config").save();

// Manual reload
Configs.load("config").reload();
```

**Key Features:**
- `.load("name")` - Load config from resources folder
- `.watch()` - Auto-reload when file changes (useful for development)
- `.get("name")` - Retrieve loaded config
- Standard Bukkit Configuration methods available
- Automatically handles file creation from resources

### 4. Messages (io.github.johnnypixelz.utilizer.text.Messages)

The Messages system provides a powerful way to send formatted messages to players from config files. Messages automatically parse colors and support multiple formats including chat messages, titles, actionbars, and sounds.

```java
// Simple message from config
Messages.cfg("messages", "welcome.message").send(player);

// With placeholder replacement
Messages.cfg("messages", "kill.message")
    .map("%player%", target.getName())
    .map("%killer%", killer.getName())
    .send(player);

// Send to multiple players
Messages.cfg("messages", "broadcast").send(playerList);

// Broadcast to all online players
Messages.cfg("messages", "announcement").broadcast();

// Broadcast with range (only players within radius)
Point center = Point.of(location);
Messages.cfg("messages", "area.event")
    .broadcast(center, 50.0);  // 50 block radius

// Broadcast with range and predicate filter
Messages.cfg("messages", "team.message")
    .broadcast(center, 100.0, player -> isOnTeam(player));
```

**Config Format Options:**

Simple string:
```yaml
welcome: "&aWelcome to the server!"
```

String list:
```yaml
rules:
  - "&6Server Rules:"
  - "&7- Be respectful"
  - "&7- No griefing"
```

Full message section (with all features):
```yaml
level-up:
  message: "&aYou leveled up!"
  title: "&6Level Up!"
  subtitle: "&eYou are now level %level%"
  actionbar: "&a+100 XP"
  sound: "ENTITY_PLAYER_LEVELUP"
  fade-in: 10
  stay: 70
  fade-out: 20
```

**Available Keys in Message Section:**
- `message` - Chat message (string or string list)
- `title` - Title text
- `subtitle` - Subtitle text
- `actionbar` - Action bar text
- `sound` - Sound to play (Minecraft sound name)
- `fade-in` - Title fade-in time in ticks (default: 20)
- `stay` - Title stay time in ticks (default: 50)
- `fade-out` - Title fade-out time in ticks (default: 30)

**Key Features:**
- Automatic color parsing (supports `&` codes and hex colors)
- Auto-detects format (string, list, or section)
- Chainable `.map()` for placeholder replacement
- Supports titles, subtitles, actionbars, and sounds
- Broadcast methods with range support
- All messages return `Message` object for chaining

**Static Message Methods:**
```java
// Send plain text (not from config)
Messages.send(player, "&aHello!");
Messages.send(player, messageList);

// Broadcast plain text
Messages.broadcast("&cServer restarting!");
Messages.broadcast(messageList);

// Broadcast with range
Messages.broadcast("Event starting!", point, 100.0);
Messages.broadcast(messageList, point, 100.0, player -> player.hasPermission("event.notify"));
```

### 5. Custom Inventories (io.github.johnnypixelz.utilizer.inventories.CustomInventory)

The Custom Inventories system provides a fluent API for creating interactive GUI menus.

```java
// Basic inventory
CustomInventory inventory = new CustomInventory()
    .title("&6My Menu")
    .type(CustomInventoryType.CHEST_3_ROWS);

// Add items using the root pane
inventory.getRootPane().setInventoryItem(0, ClickableItem.of(
    Items.edit(Material.DIAMOND).setDisplayName("&bClick me").getItem(),
    event -> event.getWhoClicked().sendMessage("Clicked!")
));

// Open for player
inventory.open(player);

// Extend for custom menus
public class ShopMenu extends CustomInventory {
    public ShopMenu() {
        title("&6Shop");
        type(CustomInventoryType.CHEST_6_ROWS);
    }

    @Override
    protected void onDraw() {
        getRootPane().setInventoryItem(0, ClickableItem.of(
            Items.edit(Material.DIAMOND).getItem(),
            event -> buyItem((Player) event.getWhoClicked())
        ));
    }

    @Override
    protected void onOpen(Player player) {
        player.sendMessage("Welcome to the shop!");
    }
}
```

**CustomInventory Methods:**
- `.title(String)` - Set inventory title (supports colors)
- `.type(CustomInventoryType)` - Set inventory type/size
- `.open(Player)` - Open inventory for player
- `.close(Player)` - Close inventory for player
- `.refresh(Long)` - Set auto-refresh interval in ticks
- `.disablePAPI()` - Disable PlaceholderAPI support
- `.openParentInventoryOnClose(CustomInventory)` - Open another inventory on close

**Lifecycle Methods (override these):**
- `onLoad()` - Called once when inventory is first created
- `onDraw()` - Called to draw items (after load, on refresh)
- `onOpen(Player)` - Called when player opens inventory
- `onClose(Player)` - Called when player closes inventory

**Item Types:**
- `ClickableItem.of(ItemStack, Consumer<InventoryClickEvent>)` - Clickable item
- `SimpleItem.of(ItemStack)` - Non-interactive display item
- `CloseItem.of(ItemStack)` - Closes inventory on click
- `SwitchItem.of(ItemStack, CustomInventory)` - Opens another inventory

**Pane Methods:**
- `.setInventoryItem(int slot, InventoryItem)` - Set item at slot
- `.setInventoryItem(int row, int col, InventoryItem)` - Set by row/column
- `.setInventoryItem(Slot, InventoryItem)` - Set using Slot object
- `.fill(Supplier<InventoryItem>)` - Fill empty slots

### 6. Storage (io.github.johnnypixelz.utilizer.file.storage.Storage)

The Storage system provides type-safe JSON file persistence for single objects, lists, and maps.

```java
// Single object storage
FileStorageHandler<PlayerData> handler = Storage.type(PlayerData.class)
    .json("playerdata", GsonProvider.standard());

// Load data
Optional<PlayerData> data = handler.load();
PlayerData data = handler.load(() -> new PlayerData()); // with default

// Save data
handler.save(playerData);
handler.saveAndBackup(playerData); // creates timestamped backup

// List storage
FileStorageHandler<List<String>> listHandler = Storage.list(String.class)
    .json("whitelist", GsonProvider.standard());

// Map storage
FileStorageHandler<Map<UUID, PlayerData>> mapHandler = Storage.map(UUID.class, PlayerData.class)
    .json("players", GsonProvider.prettyPrinting());

// Container pattern (auto-loads, tracks changes)
FileStorageContainer<PlayerData> container = handler.container(() -> new PlayerData());
PlayerData data = container.get();
container.save();
```

**Storage Factory:**
- `Storage.type(Class<T>)` - Single object storage builder
- `Storage.list(Class<T>)` - List storage builder
- `Storage.map(Class<K>, Class<V>)` - Map storage builder

**Storage Handler Methods:**
- `.json(fileName, Gson)` - Create JSON file handler
- `.load()` - Returns `Optional<T>`
- `.load(Supplier<T>)` - Load or create default
- `.save(T)` - Save data to file
- `.saveAndBackup(T)` - Save with timestamped backup
- `.container(Supplier<T>)` - Create managed container

**GsonProvider:**
- `GsonProvider.standard()` - Basic Gson instance
- `GsonProvider.prettyPrinting()` - Pretty-printed output
- `GsonProvider.builder()` - Custom GsonBuilder

### 7. Commands (io.github.johnnypixelz.utilizer.command.Command)

The Commands system provides an annotation-based approach to creating Bukkit commands with automatic argument parsing, permission handling, and subcommand support.

```java
// Basic command
@Label("mycommand|mc|mycmd")  // Aliases separated by |
@Description("My custom command")
@Permission("myplugin.command")
public class MyCommand extends Command {

    @Default  // Default method when no subcommand matches
    public void defaultCommand(Player player) {
        player.sendMessage("Hello!");
    }

    @Subcommand("give")
    @Permission("myplugin.give")
    public void giveSubcommand(Player player, int amount) {
        // /mycommand give 10
        player.sendMessage("Giving " + amount + " items");
    }

    @Subcommand("info")
    public void infoSubcommand(Player player, Player target) {
        // /mycommand info <player>
        player.sendMessage("Info about " + target.getName());
    }
}

// Register in onEnable
@Override
public void onEnable() {
    CommandManager.registerCommands(MyCommand.class);
}
```

**Annotations:**
- `@Label("name|alias1|alias2")` - Command name with aliases (on class or method)
- `@Subcommand("name")` - Subcommand name (on method or nested class)
- `@Default` - Method to call when no subcommand matches
- `@Description("text")` - Command description
- `@Permission("node")` - Required permission (repeatable)
- `@ConfigPermission(config="config", path="permissions.cmd")` - Permission from config
- `@PermissionMessage("&cNo permission!")` - Literal no-permission message
- `@PermissionConfigMessage(config="messages", path="no-perm")` - Message from config

**Method Parameters:**
- First parameter can be `CommandSender`, `Player`, or `ConsoleCommandSender`
- Remaining parameters are parsed from command arguments
- If last parameter is `String`, it joins all remaining arguments

**Built-in Argument Types:**
- Primitives: `short`, `int`, `long`, `float`, `double`, `boolean`, `char`
- Wrappers: `Short`, `Integer`, `Long`, `Float`, `Double`, `Boolean`, `Character`
- Text: `String`, `String[]`
- Bukkit: `Player`, `OfflinePlayer`, any `Enum`
- Quoted strings: `"argument with spaces"` becomes single argument

**Nested Subcommands (class-based):**
```java
@Label("shop")
public class ShopCommand extends Command {

    @Subcommand("buy")
    class BuySubcommand extends Command {
        @Default
        public void buy(Player player, String item, int amount) {
            // /shop buy diamond 5
        }

        @Subcommand("all")
        public void buyAll(Player player, String item) {
            // /shop buy all diamond
        }
    }
}
```

**Custom Argument Resolvers:**
```java
// Register custom type resolver
CommandArgumentResolverManager.registerResolver(MyType.class, context -> {
    String arg = context.getArgument();
    CommandSender sender = context.getSender();
    // Parse and return MyType
    return MyType.parse(arg);
});

// Then use in commands
@Subcommand("custom")
public void customCommand(Player player, MyType myArg) {
    // myArg is automatically parsed
}
```

**Key Methods:**
- `CommandManager.registerCommands(Class<? extends Command>...)` - Register command classes
- `CommandArgumentResolverManager.registerResolver(Class<T>, Resolver)` - Add custom type

### 8. Chat Input (io.github.johnnypixelz.utilizer.input.ChatInput)

The ChatInput system provides a fluent API for capturing player chat input with type-safe parsing, validation, and timeout support.

```java
// Basic string input
ChatInput.of(player)
    .onMessage(message -> player.sendMessage("You typed: " + message))
    .onCancel(() -> player.sendMessage("Cancelled"))
    .cancelWord("cancel")
    .sync();

// Typed input with parsing
ChatInput.of(player)
    .parseAsInt("&cPlease enter a valid number")
    .onMessage(number -> player.sendMessage("You entered: " + number))
    .retryOnInvalid()
    .sync();

// With validation and range
ChatInput.of(player)
    .parseAsInt("&cEnter a number between 1-100", 1, 100)
    .onMessage(amount -> giveCoins(player, amount))
    .timeout(30, TimeUnit.SECONDS)
    .onCancel(() -> player.sendMessage("Timed out"))
    .sync();

// Enum validation
ChatInput.of(player)
    .validateEnum("&cChoose: yes, no, maybe", "yes", "no", "maybe")
    .onMessage(choice -> handleChoice(player, choice))
    .sync();

// Custom parsing
ChatInput.of(player)
    .parseAs("&cInvalid player name", Bukkit::getPlayer)
    .onMessage(target -> teleport(player, target))
    .sync();
```

**Key Methods:**
- `ChatInput.of(Player)` - Create new input for player
- `.onMessage(Consumer<T>)` - Handler for valid input
- `.onCancel(Runnable)` - Handler for cancel/timeout/quit
- `.cancelWord(String)` - Word to type to cancel (default: none)
- `.timeout(long, TimeUnit)` - Auto-cancel after duration
- `.retryOnInvalid()` - Keep listening on invalid input
- `.sync()` / `.async()` - Start listening (sync runs handlers on main thread)

**Parsing Methods:**
- `.parseAsInt(errorMsg)` - Parse as integer
- `.parseAsInt(errorMsg, min, max)` - Integer with range
- `.parseAsLong(errorMsg)` - Parse as long
- `.parseAsDouble(errorMsg)` - Parse as double
- `.parseAs(errorMsg, Function<String, T>)` - Custom parser

**Validation Methods:**
- `.validate(errorMsg, Predicate<String>)` - Custom validation
- `.validateEnum(errorMsg, String...)` - Must match one of options

### 9. Amounts (io.github.johnnypixelz.utilizer.amount.Amount)

The Amounts system provides a flexible way to represent both static numbers and dynamic ranges. This is particularly useful for configuration files where you want to support both fixed values and random ranges.

```java
// Static amount - always returns the same value
Amount staticAmount = Amount.of(5);
int value = staticAmount.getAmount();  // Always returns 5

// Dynamic amount (range) - returns random value between min and max (inclusive)
Amount rangeAmount = Amount.range(5, 10);
int randomValue = rangeAmount.getAmount();  // Returns random number between 5-10

// Parse from string - supports both formats
Amount parsed1 = Amount.parse("5");        // Static amount of 5
Amount parsed2 = Amount.parse("5-10");     // Dynamic range 5 to 10

// Using in practice
Amount rewardAmount = Amount.parse(config.getString("reward.coins"));
int coins = rewardAmount.getAmount();
player.giveCoins(coins);

// Config file examples:
// static-reward: "100"        -> Always gives 100 coins
// random-reward: "50-150"     -> Gives between 50-150 coins
```

**Key Features:**
- `Amount.of(int)` - Create static amount (always same value)
- `Amount.range(int, int)` - Create dynamic range (random between min-max, inclusive)
- `Amount.parse(String)` - Parse from string ("5" or "5-10" format)
- `.getAmount()` - Get the value (static returns fixed, dynamic returns random)
- Perfect for config-based systems with flexible values
- Thread-safe random number generation for ranges

**Use Cases:**
- Reward systems with variable amounts
- Damage ranges for custom weapons
- Cooldown variations
- Spawn quantities
- Experience gains with randomness

### 10. Parse (io.github.johnnypixelz.utilizer.config.Parse)

The Parse system provides safe parsing utilities for converting strings to various types with Optional support or default values. It includes constraint methods to limit values to ranges and special parsers for Bukkit objects.

```java
// Parse integers safely with Optional
Optional<Integer> maybeNumber = Parse.integer("123");
if (maybeNumber.isPresent()) {
    int number = maybeNumber.get();
}

// Parse with default value
int number = Parse.integer("not a number", 10); // Returns 10
int valid = Parse.integer("42", 0); // Returns 42

// Parse decimals (doubles)
Optional<Double> maybeDecimal = Parse.decimal("3.14");
double value = Parse.decimal("invalid", 1.0); // Returns 1.0

// Parse RGB color from string (format: "r, g, b")
Color color = Parse.color("255, 128, 64");
Color defaultColor = Parse.color(null); // Returns Color.BLACK
Color white = Parse.color("invalid"); // Returns Color.WHITE

// Parse chat color from RGB
ChatColor chatColor = Parse.chatColor("255, 0, 0"); // Red
ChatColor black = Parse.chatColor(null); // Returns ChatColor.BLACK

// Constrain values to a range
int clamped = Parse.constrain(0, 100, 150); // Returns 100
int inRange = Parse.constrain(0, 100, 50);  // Returns 50
long clampedLong = Parse.constrain(0L, 1000L, -5L); // Returns 0
double clampedDouble = Parse.constrain(0.0, 1.0, 1.5); // Returns 1.0
float clampedFloat = Parse.constrain(0f, 10f, 5f); // Returns 5.0

// Parse string or string list from config (always returns list)
ConfigurationSection section = config.getConfigurationSection("messages");

// If config has: value: "single message"
List<String> list1 = Parse.stringOrList(section, "value"); 
// Returns: ["single message"]

// If config has: 
// values:
//   - "line 1"
//   - "line 2"
List<String> list2 = Parse.stringOrList(section, "values");
// Returns: ["line 1", "line 2"]
```

**Key Features:**

**Safe Parsing:**
- `Parse.integer(String)` - Returns `Optional<Integer>`
- `Parse.integer(String, int)` - Returns int with default value
- `Parse.decimal(String)` - Returns `Optional<Double>`
- `Parse.decimal(String, double)` - Returns double with default value

**Object Parsing:**
- `Parse.color(String)` - Parse Bukkit Color from "r, g, b" format
- `Parse.chatColor(String)` - Parse ChatColor from "r, g, b" format
- Returns safe defaults (BLACK/WHITE) on invalid input

**Value Constraints:**
- `Parse.constrain(min, max, value)` - Clamp value to range
- Overloads for `int`, `long`, `double`, `float`
- Throws `IllegalArgumentException` if min > max

**Config Utilities:**
- `Parse.stringOrList(ConfigurationSection, String)` - Always returns `List<String>`
- Converts single strings to single-element lists
- Handles both string and string list config entries

**Use Cases:**
- Safe config value parsing
- User input validation with defaults
- RGB color parsing from configs
- Ensuring values stay within valid ranges
- Flexible config format (string or list)

### 11. Loot Tables (io.github.johnnypixelz.utilizer.loottable.LootTable)

The Loot Tables system provides a flexible, config-based reward distribution system with support for items, commands, experience, and nested loot tables.

```java
// Parse loot table from config
ConfigurationSection lootConfig = Configs.get("config").getConfigurationSection("rewards.loot-table");
LootTable lootTable = LootTable.parse(lootConfig);
// OR
LootTable lootTable = LootTables.parseLootTable(lootConfig);

// Give loot directly to player
lootTable.giveLoot(player);

// Drop loot at location
lootTable.dropLootAt(location);

// Drop loot at location with player context (for placeholders)
lootTable.dropLootAt(player, location);

// Manual rolling (returns list of LootEntry)
List<LootEntry> rolled = lootTable.roll();
for (LootEntry entry : rolled) {
    entry.giveLoot(player);
}
```

**Configuration Schema:**

```yaml
loot-table:
  mode: INDEPENDENT          # INDEPENDENT or WEIGHTED
  chance: 1.0                # Chance entire table rolls (0.0-1.0)
  rolls: 1                   # Number of times to roll
  entries:                   # Map of loot entries
    diamonds:
      type: ITEM             # Entry type: ITEM, COMMAND, EXP, LOOT_TABLE
      material: DIAMOND
      amount: "1-3"          # Supports ranges or fixed amounts
      chance: 0.5            # 50% chance
      name: "&b&lRare Diamond"
      glow: true
    
    command-reward:
      type: COMMAND
      command: "give %player_name% diamond 5"
      chance: 0.3
    
    experience:
      type: EXP              # Also accepts XP
      amount: "30-50"        # Random 30-50 XP
      chance: 0.8
    
    nested-table:
      type: LOOT_TABLE       # Nested loot tables
      mode: WEIGHTED
      chance: 0.2
      entries:
        rare-item:
          type: ITEM
          material: NETHERITE_INGOT
          chance: 1.0
```

**Complete Example Config:**

```yaml
vote-rewards:
  mode: INDEPENDENT
  rolls: 2                   # Roll twice
  entries:
    diamonds:
      type: ITEM
      material: DIAMOND
      chance: 0.5            # 50% chance per roll
      amount: 1
    
    trident:
      type: ITEM
      material: TRIDENT
      name: "&6&lLEGENDARY TRIDENT"
      chance: 0.01           # 1% chance
      amount: 1
    
    vote-key:
      type: ITEM
      name: "&a&lVOTE KEY"
      glow: true
      material: TRIPWIRE_HOOK
      chance: 0.007
      amount: 1
    
    mythic-key:
      type: ITEM
      name: "&b&lMYTHICAL KEY"
      glow: true
      material: TRIPWIRE_HOOK
      chance: 0.005
      amount: 1
    
    nova-voucher:
      type: ITEM
      name: "&6&lNOVA VOUCHER &7&o(( RIGHT-CLICK ))"
      glow: true
      material: DIAMOND_HELMET
      chance: 0.003
      amount: 1
    
    xp:
      type: EXP
      amount: "30-50"        # Random 30-50 XP
      chance: 1.0            # Always give XP
```

**Loot Table Modes:**

1. **INDEPENDENT Mode:**
   - Each entry rolls independently based on its chance
   - Multiple entries can be selected in a single roll
   - Example: 50% for diamonds + 80% for XP = both can drop

2. **WEIGHTED Mode:**
   - Exactly one entry is selected based on weighted probabilities
   - Chance values act as weights (not percentages)
   - Example: chance 1.0 vs 9.0 = 10% vs 90% selection rate

**Entry Types:**

1. **ITEM Entry:**
   - Spawns ItemStack rewards
   - Supports all properties from `Items.parse()`: material, amount, name, lore, glow, custom-model-data, enchantments, etc.
   - Amount supports ranges: `"1-3"` or fixed: `"5"`
   - PlaceholderAPI support in name/lore when using `giveLoot(player)` or `dropLootAt(player, location)`

2. **COMMAND Entry:**
   - Executes console command
   - Supports PlaceholderAPI: `%player_name%`, `%player_uuid%`, etc.
   - Command runs as console (has all permissions)

3. **EXP/XP Entry:**
   - Gives experience to player or spawns XP orb
   - Amount supports ranges: `"30-50"` or fixed: `"100"`
   - `giveLoot()` adds XP to player directly
   - `dropLootAt()` spawns experience orb at location

4. **LOOT_TABLE Entry:**
   - Nested loot tables for complex reward structures
   - Can have different mode than parent
   - Useful for tiered reward systems

**Key Methods:**

*Parsing:*
- `LootTable.parse(ConfigurationSection)` - Parse loot table from config
- `LootTables.parseLootTable(ConfigurationSection)` - Alternative parsing method

*Execution:*
- `.giveLoot(Player)` - Give loot directly to player (items to inventory, XP to player, commands executed)
- `.dropLootAt(Location)` - Drop loot at location (items/XP orbs spawn at location)
- `.dropLootAt(Player, Location)` - Drop loot with player context for placeholders
- `.roll()` - Manually roll for loot, returns `List<LootEntry>`

*Properties:*
- `.getLootTableMode()` - Get mode (INDEPENDENT or WEIGHTED)
- `.getNestedLootEntries()` - Get list of entries
- `.getRolls()` - Get number of rolls
- `.getChance()` - Get chance this table rolls

**Registering Custom Entry Types:**

```java
// Register custom loot entry resolver
LootTables.registerLootEntryResolver("CUSTOM", section -> {
    // Parse your custom entry from config
    String customValue = section.getString("custom-property");
    double chance = section.getDouble("chance", 1.0);
    return new MyCustomLootEntry(customValue, chance);
});

// Then use in config:
// my-loot:
//   entries:
//     custom-entry:
//       type: CUSTOM
//       custom-property: "value"
//       chance: 0.5
```

**Common Use Cases:**
- Vote reward systems
- Crate/chest rewards
- Quest completion rewards
- Kill drop tables
- Random event rewards
- Tiered loot systems
- Gacha/loot box mechanics

**Best Practices:**
- Use INDEPENDENT mode for multiple possible rewards
- Use WEIGHTED mode when you want exactly one reward
- Combine modes with nested loot tables for complex systems
- Use `rolls` parameter to give multiple rewards from same table
- Keep chance values between 0.0-1.0 for INDEPENDENT mode
- In WEIGHTED mode, chance values are relative weights (can be any positive number)
- Use Amount ranges (`"1-5"`) for variety in rewards
- Store loot tables in separate config files for organization

### 12. Custom Blocks (io.github.johnnypixelz.utilizer.features.customblocks.CustomBlocks)

The Custom Blocks system allows creating blocks with custom behavior, persistent data, and item integration.

```java
// Define a custom block class
public class PowerBlock extends CustomBlock {
    public PowerBlock(BlockPosition position) {
        super(position);
    }

    @Override
    public void onTick() {
        // Called every tick (configurable interval)
    }

    @Override
    public void onRegister() {
        // Called when block is placed/created
    }

    @Override
    public void onUnregister() {
        // Called when block is broken/removed
    }

    @Override
    public void onLoad() {
        // Called when loaded from storage
    }

    @Override
    public void onUnload() {
        // Called on server shutdown
    }
}

// Create and initialize the manager
CustomBlockManager<PowerBlock> manager = CustomBlocks.create(PowerBlock.class)
    .storage("powerblocks.json")
    .build()
    .init();

// Block with item representation
CustomBlockManager<MyBlock> manager = CustomBlocks.create(MyBlock.class)
    .storage("myblocks.json")
    .item("my_block", block -> Items.edit(Material.DIAMOND_BLOCK)
        .setDisplayName("&bPower Block")
        .getItem())
    .build()
    .init();

// Block with persistent data
public class DataBlock extends CustomBlock implements BlockDataHolder<MyData> {
    private MyData data;

    public DataBlock(BlockPosition position) {
        super(position);
    }

    @Override
    public MyData getData() { return data; }

    @Override
    public void setData(MyData data) { this.data = data; }
}

CustomBlockManager<DataBlock> manager = CustomBlocks.create(DataBlock.class)
    .storage("datablocks.json")
    .data(MyData.class)
    .build()
    .init();

// Register block at position
manager.register(new PowerBlock(BlockPosition.of(block)));

// Get block at position
Optional<PowerBlock> block = manager.get(blockPosition);

// Unregister (remove) block
manager.unregister(blockPosition);
```

**Builder Methods:**
- `.storage(String fileName)` - JSON storage file name
- `.item(String id, Function<CB, ItemStack>)` - Item representation
- `.data(Class<D>)` - Enable persistent data (requires BlockDataHolder)
- `.build()` - Create manager
- `.init()` - Initialize and start ticking

**Lifecycle Methods (override in CustomBlock):**
- `onTick()` - Called each tick
- `onRegister()` - When placed/created
- `onUnregister()` - When broken/removed
- `onLoad()` - When loaded from storage
- `onUnload()` - On server shutdown

### 13. SQL (io.github.johnnypixelz.utilizer.sql.SQL)

The SQL system provides connection pooling (HikariCP) and simple query execution for MySQL, MariaDB, and PostgreSQL.

```java
// Create credentials from config
DatabaseCredentials credentials = DatabaseCredentials.fromConfig(
    Configs.get("config").getConfigurationSection("database"),
    new MysqlDriver(),      // Supported drivers
    new MariaDBDriver(),
    new PostgresqlDriver()
);

// Or create manually
DatabaseCredentials credentials = DatabaseCredentials.of(
    "localhost",            // address
    3306,                   // port
    "minecraft",            // database
    "root",                 // username
    "password",             // password
    new MysqlDriver()       // driver
);

// Create SQL client
SQLClient client = SQL.newClient(credentials);

// Execute statement (no return)
client.execute("CREATE TABLE IF NOT EXISTS players (uuid VARCHAR(36) PRIMARY KEY, coins INT)");

// Execute with prepared statement
client.execute("INSERT INTO players (uuid, coins) VALUES (?, ?)", ps -> {
    ps.setString(1, player.getUniqueId().toString());
    ps.setInt(2, 100);
});

// Execute async (runs on separate thread)
client.executeAsync("UPDATE players SET coins = coins + 10 WHERE uuid = ?", ps -> {
    ps.setString(1, uuid.toString());
});

// Query with result
Optional<Integer> coins = client.executeQuery(
    "SELECT coins FROM players WHERE uuid = ?",
    ps -> ps.setString(1, uuid.toString()),
    rs -> rs.next() ? rs.getInt("coins") : null
);

// Close client when done (in onDisable)
client.close();
```

**Config Format:**
```yaml
database:
  mode: mysql           # mysql, mariadb, or postgresql
  address: localhost
  port: 3306
  database: minecraft
  username: root
  password: password
  properties:           # Optional HikariCP properties
    useSSL: false
```

**Key Methods:**
- `SQL.newClient(DatabaseCredentials)` - Create connection pool
- `.execute(String)` - Execute SQL statement
- `.execute(String, PreparedStatementHandler)` - Execute with parameters
- `.executeAsync(String)` - Execute asynchronously
- `.executeQuery(String, PreparedStatementHandler, ResultSetHandler)` - Query with result
- `.getConnection()` - Get raw JDBC connection
- `.close()` - Close connection pool

**Drivers:**
- `MysqlDriver` - MySQL
- `MariaDBDriver` - MariaDB
- `PostgresqlDriver` - PostgreSQL

### 14. Placeholders (io.github.johnnypixelz.utilizer.depend.Placeholders)

The Placeholders system provides a unified way to register and use placeholders in text. It automatically integrates with PlaceholderAPI when available.

#### Using Placeholders

```java
// Process placeholders in text
String message = Placeholders.set(player, "Hello %player%! Online: %server_online%");
player.sendMessage(message);

// Works with null player (only static placeholders processed)
String serverInfo = Placeholders.set(null, "Server: %server_name% (%server_online%/%server_max%)");

// Process only static placeholders
String staticOnly = Placeholders.setStatic("Online: %server_online%");
```

#### Registering Custom Placeholders

```java
@Override
public void onEnable() {
    // Player-based placeholder: %coins%
    Placeholders.register("coins", player -> {
        return String.valueOf(getCoins(player));
    });

    // Static placeholder (no player needed): %server_tps%
    Placeholders.register("server_tps", () -> {
        return String.format("%.1f", getTPS());
    });
}
```

#### Built-in Placeholders

**Player placeholders** (require player context):
- `%player%`, `%player_name%` - Player's name
- `%player_displayname%` - Player's display name
- `%player_uuid%` - Player's UUID
- `%player_world%` - Player's current world
- `%player_health%` - Player's health (integer)
- `%player_food%` - Player's food level
- `%player_level%` - Player's XP level
- `%player_gamemode%` - Player's gamemode
- `%player_x%`, `%player_y%`, `%player_z%` - Player's coordinates

**Static placeholders** (no player needed):
- `%server_online%` - Online player count
- `%server_max%` - Max player count
- `%server_name%` - Server name
- `%server_version%` - Server version
- `%server_motd%` - Server MOTD

**Processing Order:**
1. Internal registered placeholders are processed first
2. PlaceholderAPI placeholders are processed second (if PAPI is installed)

**Placeholders Methods:**
- `Placeholders.set(Player, String)` - Process all placeholders (internal + PAPI)
- `Placeholders.set(OfflinePlayer, String)` - Process placeholders (static + PAPI for offline)
- `Placeholders.setStatic(String)` - Process only static placeholders (no PAPI)
- `Placeholders.register(String, Function<Player, String>)` - Register player placeholder
- `Placeholders.register(String, Supplier<String>)` - Register static placeholder
- `Placeholders.unregister(String)` - Unregister a placeholder
- `Placeholders.isRegistered(String)` - Check if placeholder exists

### 15. PlaceholderAPI Expansion (io.github.johnnypixelz.utilizer.papi)

Modern fluent API for creating PlaceholderAPI expansions with template pattern support.

#### Creating an Expansion

```java
PlaceholderExpansion.create()
    // Simple: %plugin_coins%
    .placeholder("coins", player -> String.valueOf(getCoins(player)))

    // With args: %plugin_stat_mining%
    .placeholder("stat_{type}", (player, args) -> {
        return getStat(player, args.getString("type"));
    })

    // Complex: %plugin_leaderboard_mining_top_1%
    .placeholder("leaderboard_{skill}_top_{position}", (player, args) -> {
        String skill = args.getString("skill");
        int position = args.getInt("position");
        return getLeaderboardEntry(skill, position);
    })

    // Relational: %rel_plugin_canattack%
    .relational("canattack", (p1, p2) -> canAttack(p1, p2) ? "yes" : "no")

    // Relational with args: %rel_plugin_relationship_friend%
    .relational("relationship_{type}", (p1, p2, args) -> {
        return getRelationship(p1, p2, args.getString("type"));
    })

    .register();
```

#### Template Patterns

Use `{name}` syntax to capture dynamic parts:
- `"stat_{type}"` - captures "type" from "stat_mining"
- `"leaderboard_{skill}_top_{position}"` - captures "skill" and "position"

Access captured values through `PlaceholderArgs`:
- `args.getString("type")` - get as string
- `args.getInt("position")` - get as int (returns 0 if invalid)
- `args.getDouble("amount")` - get as double
- `args.has("key")` - check if key exists

**PlaceholderExpansion Methods:**
- `PlaceholderExpansion.create()` - Create new builder
- `.placeholder(String, Function<Player, String>)` - Simple placeholder
- `.placeholder(String, BiFunction<Player, PlaceholderArgs, String>)` - With template args
- `.relational(String, BiFunction<Player, Player, String>)` - Simple relational
- `.relational(String, TriFunction<Player, Player, PlaceholderArgs, String>)` - Relational with args
- `.register()` - Register with PlaceholderAPI

**PlaceholderArgs Methods:**
- `.getString(String key)` - Get string value (nullable)
- `.getString(String key, String default)` - Get string with default
- `.getInt(String key)` / `.getInt(String key, int default)` - Get int
- `.getLong(String key)` / `.getLong(String key, long default)` - Get long
- `.getDouble(String key)` / `.getDouble(String key, double default)` - Get double
- `.has(String key)` - Check if key exists
- `.keys()` - Get all keys
- `.raw()` - Get original unparsed params string

### 16. Plugin Hooks (io.github.johnnypixelz.utilizer.depend.Dependencies)

The Plugin Hooks system provides integration with popular Bukkit plugins like Vault.

#### Vault Integration

```java
// Get Vault wrapper for economy/permissions
Dependencies.getVault().ifPresent(vault -> {
    // Use Vault economy, permissions, etc.
});
```

#### Checking for Other Plugins

```java
// Check if a plugin is loaded
if (Dependencies.isLoaded("Vault")) {
    // Plugin is loaded
}

// Check if a plugin is enabled
if (Dependencies.isEnabled("Vault")) {
    // Plugin is enabled and ready to use
}
```

**Dependencies Methods:**
- `Dependencies.getVault()` - Returns `Optional<VaultWrapper>`
- `Dependencies.isLoaded(String)` - Check if plugin is loaded
- `Dependencies.isEnabled(String)` - Check if plugin is enabled
- `Dependencies.getPlaceholderAPI()` - **Deprecated**, use `PlaceholderExpansion` instead

### 17. Serialization (io.github.johnnypixelz.utilizer.serialize.world)

The Serialization package provides immutable, JSON-serializable location objects that are safer to store and pass around than Bukkit's mutable Location.

```java
// Point - immutable location (x, y, z, world)
Point point = Point.of(100.5, 64.0, -200.5, "world");
Point fromLoc = Point.of(location);
Point fromBlock = Point.of(block);

// Convert back to Bukkit Location
Location loc = point.toLocation();

// Operations (all return new Point, original unchanged)
Point moved = point.add(10, 0, -5);
Point relative = point.getRelative(BlockFace.UP);
Point centered = point.center();        // Center of block
Point floorCenter = point.horizontalCenter();

// Distance calculations
double dist = point.distance(otherPoint);

// BlockPosition - integer coordinates (for block operations)
BlockPosition blockPos = point.floor();
BlockPosition pos = BlockPosition.of(100, 64, -200, "world");

// Position - point with direction (yaw/pitch)
Position position = Position.of(location);
Position withDir = point.withDirection(Direction.of(90f, 0f));
Location fullLoc = position.toLocation();  // Includes yaw/pitch

// Direction - yaw and pitch
Direction dir = Direction.from(location);
Direction dir = Direction.of(45f, -30f);  // yaw, pitch

// Region - 3D box between two points
Region region = Region.of(point1, point2);
Region region = point1.regionWith(point2);

boolean inside = region.inRegion(player.getLocation());
boolean inside = region.inRegion(100, 64, -200);

Point min = region.getMin();
Point max = region.getMax();
double width = region.getWidth();

// JSON serialization (for storage)
JsonObject json = point.serialize();
Point restored = Point.deserialize(jsonElement);
```

**Classes:**
- `Point` - Immutable x, y, z, world (double coordinates)
- `BlockPosition` - Immutable block x, y, z, world (int coordinates)
- `Position` - Point + Direction (includes yaw/pitch)
- `Direction` - Yaw and pitch
- `Region` - 3D box between two Points
- `ChunkPosition` - Chunk x, z, world
- `CircularRegion` - Circular area (center + radius)

**Key Features:**
- Immutable - safe to store and pass around
- JSON serializable via `GsonSerializable` interface
- Cached Bukkit Location for performance
- Distance calculations
- Relative operations (add, subtract, getRelative)

### 18. Minigames (io.github.johnnypixelz.utilizer.minigame.Minigame)

The Minigames framework provides a structured approach to creating minigames with arenas, modules, and lifecycle events.

```java
// Create arena class
public class MyArena extends Arena {
    private final Point spawnPoint;

    public MyArena(String name, Point spawnPoint) {
        super(name);
        this.spawnPoint = spawnPoint;
    }

    public Point getSpawnPoint() {
        return spawnPoint;
    }
}

// Create minigame class
public class MyMinigame extends Minigame<MyArena> {

    public MyMinigame(MyArena arena) {
        super(arena);

        // Set player limit
        maximumPlayerLimit = 8;

        // Register modules
        registerModules(
            new TeleportModule(this),
            new GamemodeModule(this, GameMode.SURVIVAL),
            new InvincibilityModule(this),
            new SnapshotModule(this)  // Saves/restores player inventory
        );

        // Listen to lifecycle events
        getEventManager().getOnMinigameStart().listen(() -> {
            getPlayerObjects().forEach(p -> p.sendMessage("Game started!"));
        });

        getEventManager().getOnMinigameFinish().listen(() -> {
            getPlayerObjects().forEach(p -> p.sendMessage("Game over!"));
        });
    }
}

// Usage
MyArena arena = new MyArena("arena1", Point.of(0, 64, 0, "world"));
MyMinigame game = new MyMinigame(arena);

game.join(player1);
game.join(player2);
game.start();

// When game ends
game.finish();  // Triggers cleanup after delay
```

**Game States:**
- `WAITING` - Accepting players
- `STARTED` - Game in progress
- `FINISHED` - Game ended, cleanup pending
- `CLEANED_UP` - Fully cleaned up

**Built-in Modules:**
- `TeleportModule` - Teleport players to spawn
- `GamemodeModule` - Set gamemode during game
- `InvincibilityModule` - Prevent damage
- `SnapshotModule` - Save/restore player state
- `SaturationModule` - Keep players fed
- `SpectateModule` - Spectator mode on death
- `TeamsModule` - Team management
- `FreezeModule` - Freeze players
- `WarmUpModule` - Pre-game warmup
- `DeathModule` - Handle player deaths
- `BroadcastModule` - Message broadcasting

**Event Manager (getEventManager()):**
- `.getOnPlayerJoin()` - Player joins
- `.getOnPlayerRemove()` - Player removed
- `.getOnPlayerDisconnect()` - Player disconnects
- `.getOnMinigameStart()` - Game starts
- `.getOnMinigameFinish()` - Game finishes
- `.getOnMinigameCleanup()` - Cleanup phase

**Arena Types:**
- `Arena` - Base arena class
- `FFAArena` - Free-for-all arena
- `TeamedArena` - Team-based arena

### 19. Event Emitters (io.github.johnnypixelz.utilizer.event)

The Event Emitters system provides a simple pub/sub pattern for custom events with priority support.

```java
// Stateless emitter - no data passed
StatelessEventEmitter onGameStart = new StatelessEventEmitter();

// Listen for event
onGameStart.listen(() -> {
    Bukkit.broadcastMessage("Game started!");
});

// Listen with priority
onGameStart.listen(() -> {
    // Runs first
}, EventPriority.HIGHEST);

// Emit the event
onGameStart.emit();

// Stateful emitter - passes data to listeners
StatefulEventEmitter<Player> onPlayerJoin = new StatefulEventEmitter<>();

onPlayerJoin.listen(player -> {
    player.sendMessage("Welcome!");
});

onPlayerJoin.emit(player);

// BiStateful emitter - passes two values
BiStatefulEventEmitter<Player, Integer> onScoreChange = new BiStatefulEventEmitter<>();

onScoreChange.listen((player, score) -> {
    player.sendMessage("Score: " + score);
});

onScoreChange.emit(player, 100);

// Store listener reference to unregister later
StatefulEventListener<Player> listener = onPlayerJoin.listen(p -> {
    p.sendMessage("Hello!");
});

// Unregister listener
onPlayerJoin.unregister(listener);
// Or via listener itself
listener.unregister();
```

**Emitter Types:**
- `StatelessEventEmitter` - No data, just triggers listeners
- `StatefulEventEmitter<T>` - Passes single value to listeners
- `BiStatefulEventEmitter<T1, T2>` - Passes two values to listeners

**Key Methods:**
- `.listen(Consumer/Runnable)` - Register listener, returns listener reference
- `.listen(Consumer/Runnable, EventPriority)` - Register with priority
- `.emit()` / `.emit(T)` / `.emit(T1, T2)` - Fire event to all listeners
- `.unregister(Listener)` - Remove specific listener
- `.getListeners()` - Get all registered listeners

**Common Use Cases:**
- Custom game events (start, end, phase change)
- State change notifications
- Decoupling components
- Plugin API hooks

### 20. Cooldowns (io.github.johnnypixelz.utilizer.cooldown.Cooldown)

The Cooldown system provides an easy way to manage time-based restrictions on objects. Behind the scenes, it's a thread-safe map that tracks when cooldowns expire.

#### Basic Cooldown

```java
// Create a cooldown for UUIDs (players)
Cooldown<UUID> abilityCooldown = new Cooldown<>();

// Set a cooldown (in milliseconds)
abilityCooldown.set(player.getUniqueId(), 5000L); // 5 seconds

// Check if on cooldown
if (abilityCooldown.isOnCooldown(player.getUniqueId())) {
    long expiryTime = abilityCooldown.getCooldown(player.getUniqueId());
    long remaining = expiryTime - System.currentTimeMillis();
    player.sendMessage("Wait " + (remaining / 1000) + " more seconds!");
    return;
}

// Add time to existing cooldown
abilityCooldown.add(player.getUniqueId(), 2000L); // Add 2 more seconds

// Remove from cooldown manually
abilityCooldown.remove(player.getUniqueId());

// Can use any object type
Cooldown<String> commandCooldown = new Cooldown<>();
Cooldown<Location> locationCooldown = new Cooldown<>();
```

#### DynamicCooldown

io.github.johnnypixelz.utilizer.cooldown.DynamicCooldown extends io.github.johnnypixelz.utilizer.cooldown.Cooldown with automatic cleanup and callback support. It runs a background task that automatically removes expired cooldowns and executes callbacks.

```java
// Create dynamic cooldown
DynamicCooldown<UUID> rewardCooldown = new DynamicCooldown<>();

// Set callback for when cooldown expires (runs on main thread)
rewardCooldown.setOnDone(uuid -> {
    Player player = Bukkit.getPlayer(uuid);
    if (player != null) {
        player.sendMessage("Your cooldown has expired!");
    }
});

// Set async callback (runs asynchronously)
rewardCooldown.setOnDoneAsync(uuid -> {
    // Async operations when cooldown expires
    // Don't access Bukkit API here!
});

// Set cooldown
rewardCooldown.set(player.getUniqueId(), 60000L); // 1 minute

// Remove without triggering callback
rewardCooldown.removeWithoutExecuting(player.getUniqueId());

// Clean up when done (stops background task)
rewardCooldown.terminate();
```

#### DynamicPlayerCooldown

io.github.johnnypixelz.utilizer.cooldown.DynamicPlayerCooldown extends io.github.johnnypixelz.utilizer.cooldown.DynamicCooldown specifically for Players. It automatically cleans up cooldowns when players leave the server.

```java
// Automatically removes player cooldowns on disconnect
DynamicPlayerCooldown playerCooldown = new DynamicPlayerCooldown();

playerCooldown.setOnDone(player -> {
    player.sendMessage("Cooldown finished!");
});

playerCooldown.set(player, 30000L); // 30 seconds

// Player disconnects? Cooldown is automatically removed (without triggering callback)
```

**Note:** `DynamicPlayerCooldown` is less commonly used. Most use cases prefer `Cooldown` or `DynamicCooldown` for manual state management.

**Key Features:**
- **Cooldown**: Simple map-based cooldown tracking
  - `.set(object, ms)` - Set cooldown for object (milliseconds)
  - `.add(object, ms)` - Add time to existing cooldown
  - `.remove(object)` - Remove from cooldown
  - `.isOnCooldown(object)` - Check if still on cooldown
  - `.getCooldown(object)` - Get expiry timestamp

- **DynamicCooldown**: Auto-cleanup with callbacks
  - All Cooldown methods
  - `.setOnDone(Consumer)` - Callback when cooldown expires (sync)
  - `.setOnDoneAsync(Consumer)` - Async callback
  - `.removeWithoutExecuting(object)` - Remove without callback
  - `.terminate()` - Stop background task

- **DynamicPlayerCooldown**: Player-specific with auto-cleanup on disconnect
  - All DynamicCooldown features
  - Automatically removes cooldowns when players quit

**Common Use Cases:**
- Ability cooldowns
- Command rate limiting
- Teleport delays
- Chat spam prevention
- Reward claim restrictions

### 20. Logging (io.github.johnnypixelz.utilizer.plugin.Logs)

Simple logging utility that wraps the plugin logger for easy access throughout your code.

```java
// Info level logging
Logs.info("Plugin initialized successfully");
Logs.info("Player " + player.getName() + " joined the game");

// Warning level logging
Logs.warn("Configuration file is using deprecated format");
Logs.warn("Player attempted invalid action");

// Severe/Error level logging
Logs.severe("Failed to connect to database!");
Logs.severe("Critical error in game loop");
```

### 21. Random Utilities (io.github.johnnypixelz.utilizer.random.Randoms)

The `Randoms` class provides static utility methods for random selection operations.

```java
// Pick random element from collection
String item = Randoms.pick(itemList);
Material mat = Randoms.pick(Material.DIAMOND, Material.GOLD_INGOT, Material.IRON_INGOT);

// Weighted random selection
List<Weighted<String>> weightedItems = List.of(
    Weighted.of("Common", 50.0),
    Weighted.of("Rare", 10.0),
    Weighted.of("Legendary", 1.0)
);
String selected = Randoms.weighted(weightedItems);

// Chance checks
if (Randoms.chance(0.5)) { /* 50% chance */ }
if (Randoms.percent(25)) { /* 25% chance */ }
```

**Key Methods:**
- `Randoms.pick(List<T>)` - Random element from list
- `Randoms.pick(T...)` - Random element from varargs
- `Randoms.weighted(Collection<Weighted<T>>)` - Weighted random selection
- `Randoms.chance(double)` - Returns true with probability 0.0-1.0
- `Randoms.percent(double)` - Returns true with percentage 0-100

**Weighted Class:**
```java
Weighted<String> item = Weighted.of("value", 10.0);
item.getValue();  // "value"
item.getWeight(); // 10.0
```

### 22. Number Formatting (io.github.johnnypixelz.utilizer.text.Numbers)

The `io.github.johnnypixelz.utilizer.text.Numbers` class provides utilities for formatting numbers into human-readable strings with various formats.

```java
// Format with commas
long amount = 1234567890L;
String formatted = Numbers.toFormatted(amount);
// Returns: "1,234,567,890"

// Rounded format with suffixes
long bigNumber = 1_500_000L;
String rounded = Numbers.toRoundedFormatted(bigNumber);
// Returns: "1.5M"

long thousand = 5_000L;
String shortForm = Numbers.toRoundedFormatted(thousand);
// Returns: "5k"

// More examples of rounded formatting
Numbers.toRoundedFormatted(999L);          // "999"
Numbers.toRoundedFormatted(1_000L);        // "1k"
Numbers.toRoundedFormatted(5_500L);        // "5.5k"
Numbers.toRoundedFormatted(10_000L);       // "10k"
Numbers.toRoundedFormatted(1_000_000L);    // "1M"
Numbers.toRoundedFormatted(2_500_000L);    // "2.5M"
Numbers.toRoundedFormatted(1_000_000_000L); // "1B"

// Convert to Roman numerals
String roman = Numbers.toRoman(42);
// Returns: "XLII"

Numbers.toRoman(1);    // "I"
Numbers.toRoman(4);    // "IV"
Numbers.toRoman(9);    // "IX"
Numbers.toRoman(58);   // "LVIII"
Numbers.toRoman(1994); // "MCMXCIV"

// Practical usage examples
player.sendMessage("Balance: " + Numbers.toFormatted(playerBalance));
player.sendMessage("Coins: " + Numbers.toRoundedFormatted(coins));
item.setDisplayName("Level " + Numbers.toRoman(enchantLevel));
```

**Available Suffixes (toRoundedFormatted):**
- k (thousand) - 1,000
- M (million) - 1,000,000
- B (billion) - 1,000,000,000
- T (trillion) - 1,000,000,000,000
- q (quadrillion) - 1,000,000,000,000,000
- Q (quintillion) - 1,000,000,000,000,000,000

**Key Methods:**
- `Numbers.toFormatted(long)` - Format with commas (e.g., "1,234,567")
- `Numbers.toRoundedFormatted(long)` - Round with suffixes (e.g., "1.5M")
- `Numbers.toRoman(int)` - Convert to Roman numerals (e.g., "XLII")

**Key Features:**
- Works with negative numbers (toFormatted and toRoundedFormatted)
- Decimal precision for rounded format (shows one decimal when < 100)
- Locale-aware formatting (uses US format with commas)
- Handles edge cases like Long.MIN_VALUE

**Common Use Cases:**
- Economy/currency displays
- Scoreboard statistics
- Leaderboards with large numbers
- Item stack amounts
- Level displays (Roman numerals)
- Enchantment levels (Roman numerals)

### 23. Color Formatting (io.github.johnnypixelz.utilizer.text.Colors)

The `io.github.johnnypixelz.utilizer.text.Colors` class provides color parsing utilities that support both legacy `&` color codes and modern hex colors.

```java
// Parse colors with & codes
String colored = Colors.color("&aGreen text &bwith &ccyan and red");

// Parse hex colors
String hexColored = Colors.color("&#FF5733This is custom orange");
String mixed = Colors.color("&aBold and &#00FF00custom green");

// Create ChatColor from RGB values
ChatColor customColor = Colors.rgb(255, 87, 51);
player.sendMessage(customColor + "Custom colored message");

// Practical examples
player.sendMessage(Colors.color("&6&lWelcome &r&#FFD700to the server!"));
item.setDisplayName(Colors.color("&#FF0000L&#FF3300e&#FF6600g&#FF9900e&#FFCC00n&#FFFF00d&#CCFF00a&#99FF00r&#66FF00y"));

// Always use Colors.color() for parsing text
String message = Colors.color(config.getString("message"));
player.sendMessage(message);
```

**Key Methods:**
- `Colors.color(String)` - Parse both `&` codes and hex colors (`&#RRGGBB`)
- `Colors.rgb(int, int, int)` - Create ChatColor from RGB values (0-255)

**Supported Formats:**
- Legacy codes: `&a`, `&b`, `&c`, `&l` (bold), `&o` (italic), etc.
- Hex colors: `&#RRGGBB` (e.g., `&#FF5733`, `&#00FF00`)
- Mixed: Combine both in the same string

**Key Features:**
- Automatic parsing of both legacy and modern color formats
- Thread-safe pattern matching for hex colors
- Returns colored string ready for display
- Works with all Minecraft text components

**Common Use Cases:**
- Parsing messages from config files
- Coloring item names and lore
- Custom scoreboard text
- Chat message formatting
- Signs and holograms
- Book content

**Best Practice:**
- **ALWAYS use `Colors.color()` for parsing text** - All text that contains color codes should be passed through this method
- Apply before sending messages or setting display names
- Store uncolored text in configs, parse when displaying

### 24. Scoreboards (io.github.johnnypixelz.utilizer.scoreboard.Scoreboards)

The Scoreboards API provides flicker-free sidebar scoreboards with per-player placeholder support and auto-updates.

```java
// Create a scoreboard with fluent builder
Scoreboard scoreboard = Scoreboards.create("&6&lMY SERVER")
    .line(0, "&7Welcome, &e%player_name%")
    .line(1, "")
    .line(2, "&7Balance: &a$%vault_eco_balance%")
    .line(3, "&7Online: &e%server_online%")
    .line(4, "")
    .line(5, "&ewww.example.com")
    .autoUpdate(20L);  // Refresh placeholders every second

// Show to player
scoreboard.show(player);

// Update placeholders for specific player
Scoreboards.update(player);

// Update all viewers
scoreboard.updateAll();

// Dynamic line updates
scoreboard.line(2, "&7Balance: &a$" + newBalance);

// Query
if (Scoreboards.isShowing(player)) {
    Scoreboard current = Scoreboards.getFor(player);
}

// Hide from player
Scoreboards.hide(player);

// Cleanup
scoreboard.destroy();

// Plugin shutdown
Scoreboards.shutdown();
```

**Key Methods:**
- `Scoreboards.create(String title)` - Create new scoreboard
- `Scoreboards.show(Player, Scoreboard)` - Show scoreboard to player
- `Scoreboards.hide(Player)` - Hide scoreboard from player
- `Scoreboards.update(Player)` - Update placeholders for player
- `Scoreboards.getFor(Player)` - Get player's current scoreboard
- `Scoreboards.isShowing(Player)` - Check if player has a scoreboard
- `Scoreboards.shutdown()` - Shutdown service

**Scoreboard Builder:**
- `.title(String)` - Set title (supports colors/placeholders)
- `.line(int index, String text)` - Set line at index (0-14, 0 = top)
- `.lines(String...)` - Set multiple lines at once
- `.lines(List<String>)` - Set lines from list
- `.removeLine(int index)` - Remove specific line
- `.clearLines()` - Remove all lines
- `.autoUpdate(long ticks)` - Enable auto-refresh
- `.stopAutoUpdate()` - Disable auto-refresh

**Key Features:**
- Flicker-free updates using team prefix/suffix technique
- Per-player placeholder resolution (PlaceholderAPI + built-in)
- Maximum 15 lines (Minecraft limitation)
- Auto-update for live placeholder refreshing
- One scoreboard per player (showing new hides old)

### 25. Bossbars (io.github.johnnypixelz.utilizer.bossbar.Bossbars)

The Bossbars API provides a fluent interface for creating boss bars with per-player placeholder support, auto-updates, and full customization.

```java
// Simple bossbar
Bossbar bar = Bossbars.create("&c&lBOSS FIGHT")
    .color(BarColor.RED)
    .style(BarStyle.SEGMENTED_10)
    .progress(1.0);

bar.show(player);

// With placeholders and auto-update
Bossbar levelBar = Bossbars.create("&eLevel: &f%player_level% &7| &eXP: &f%player_exp%")
    .color(BarColor.YELLOW)
    .style(BarStyle.SOLID)
    .progress(0.75)
    .autoUpdate(20L);  // Update every second

levelBar.show(player);

// Progress animation (e.g., ability cooldown)
Bossbar cooldown = Bossbars.create("&bAbility Cooldown")
    .color(BarColor.BLUE)
    .progress(0.0);

cooldown.show(player);
cooldown.progress(0.5);  // Update progress
cooldown.progress(1.0);

// With flags (darken sky, fog, boss music)
Bossbar bossBar = Bossbars.create("&4&lDRAGON")
    .color(BarColor.PURPLE)
    .flags(BarFlag.DARKEN_SKY, BarFlag.CREATE_FOG)
    .progress(0.8);

// Multiple bossbars per player
Bossbar quest = Bossbars.create("&aQuest: Kill 10 zombies &7[5/10]")
    .color(BarColor.GREEN)
    .progress(0.5);

Bossbar event = Bossbars.create("&dDouble XP Event!")
    .color(BarColor.PINK);

quest.show(player);
event.show(player);  // Both visible simultaneously

// Query player's bossbars
List<Bossbar> bars = Bossbars.getFor(player);

// Cleanup
bar.hide(player);
bar.destroy();

// Hide all from player
Bossbars.hideAll(player);

// Plugin shutdown
Bossbars.shutdown();
```

**Key Methods:**
- `Bossbars.create(String title)` - Create new bossbar
- `Bossbars.create(String, BarColor)` - Create with color
- `Bossbars.create(String, BarColor, BarStyle)` - Create with color and style
- `Bossbars.show(Player, Bossbar)` - Show to player
- `Bossbars.hide(Player, Bossbar)` - Hide specific bossbar
- `Bossbars.hideAll(Player)` - Hide all bossbars from player
- `Bossbars.getFor(Player)` - Get player's bossbars
- `Bossbars.isShowing(Player)` - Check if player has any bossbars
- `Bossbars.shutdown()` - Shutdown service

**Bossbar Builder:**
- `.title(String)` - Set title (supports colors/placeholders)
- `.progress(double)` - Set progress (0.0 to 1.0)
- `.color(BarColor)` - Set bar color (PINK, BLUE, RED, GREEN, YELLOW, PURPLE, WHITE)
- `.style(BarStyle)` - Set style (SOLID, SEGMENTED_6, SEGMENTED_10, SEGMENTED_12, SEGMENTED_20)
- `.addFlag(BarFlag)` - Add flag (DARKEN_SKY, PLAY_BOSS_MUSIC, CREATE_FOG)
- `.removeFlag(BarFlag)` - Remove flag
- `.flags(BarFlag...)` - Set flags (replaces existing)
- `.autoUpdate(long ticks)` - Enable auto-refresh
- `.stopAutoUpdate()` - Disable auto-refresh

**Key Features:**
- Per-player title resolution for placeholders
- Multiple bossbars per player (recommended max: 5-6 for UI space)
- Auto-update for live placeholder refreshing
- All Bukkit BarColor, BarStyle, and BarFlag options
- Automatic cleanup on player quit

### 26. Currencies (io.github.johnnypixelz.utilizer.currency.Currencies)

The Currencies API provides a unified interface to interact with multiple economy plugins through a single API.

```java
// Get currency by ID
Optional<Currency> vault = Currencies.get("vault");
vault.ifPresent(c -> c.deposit(player, 100));

// CoinsEngine multi-currency (format: "coinsengine:<currency>")
Optional<Currency> gems = Currencies.get("coinsengine:gems");
gems.ifPresent(c -> c.withdraw(player, 50));

// Convenience methods with TransactionResult
TransactionResult result = Currencies.withdraw("vault", player, 100);
if (result.success()) {
    player.sendMessage("Withdrew $100! New balance: $" + result.balanceAfter());
} else {
    switch (result.reason()) {
        case INSUFFICIENT_FUNDS -> player.sendMessage("Not enough money!");
        case CURRENCY_UNAVAILABLE -> player.sendMessage("Economy not available!");
        case NEGATIVE_AMOUNT -> player.sendMessage("Invalid amount!");
        default -> player.sendMessage("Transaction failed!");
    }
}

// Other convenience methods
double balance = Currencies.getBalance("vault", player);
boolean canAfford = Currencies.has("playerpoints", player, 500);
Currencies.deposit("tokenenchant", player, 100);
Currencies.setBalance("vault", player, 1000);

// List all available currencies
for (Currency currency : Currencies.getAvailable()) {
    System.out.println(currency.getId() + ": " + currency.getBalance(player));
}

// Register custom currency
Currencies.register(new Currency() {
    @Override public String getId() { return "myplugin:tokens"; }
    @Override public String getName() { return "Tokens"; }
    @Override public boolean isAvailable() { return true; }
    @Override public double getBalance(OfflinePlayer player) { return getTokens(player); }
    @Override public boolean has(OfflinePlayer player, double amount) { return getBalance(player) >= amount; }
    @Override public TransactionResult withdraw(OfflinePlayer player, double amount) { /* ... */ }
    @Override public TransactionResult deposit(OfflinePlayer player, double amount) { /* ... */ }
    @Override public TransactionResult setBalance(OfflinePlayer player, double amount) { /* ... */ }
});

// Unregister currency
Currencies.unregister("myplugin:tokens");
```

**Supported Economy Plugins:**
- **Vault** - Any Vault-compatible economy (`vault`)
- **PlayerPoints** - Points system (`playerpoints`)
- **CoinsEngine** - Multi-currency support (`coinsengine:<currency>`)
- **TokenEnchant** - Token system (`tokenenchant`)

**Key Methods:**
- `Currencies.get(String id)` - Get currency by ID (Optional)
- `Currencies.getAll()` - Get all registered currencies
- `Currencies.getAvailable()` - Get only available currencies
- `Currencies.exists(String id)` - Check if currency exists
- `Currencies.register(Currency)` - Register custom currency
- `Currencies.unregister(String id)` - Unregister currency

**Convenience Methods:**
- `Currencies.getBalance(String id, OfflinePlayer)` - Get balance
- `Currencies.has(String id, OfflinePlayer, double)` - Check if has amount
- `Currencies.withdraw(String id, OfflinePlayer, double)` - Withdraw (returns TransactionResult)
- `Currencies.deposit(String id, OfflinePlayer, double)` - Deposit (returns TransactionResult)
- `Currencies.setBalance(String id, OfflinePlayer, double)` - Set balance (returns TransactionResult)

**TransactionResult:**
```java
TransactionResult result = Currencies.withdraw("vault", player, 100);
result.success();       // boolean - was transaction successful?
result.reason();        // Reason enum - why it failed (if failed)
result.balanceBefore(); // double - balance before transaction
result.balanceAfter();  // double - balance after transaction
result.amountChanged(); // double - actual amount changed
```

**TransactionResult.Reason enum:**
- `SUCCESS` - Transaction completed successfully
- `INSUFFICIENT_FUNDS` - Not enough balance
- `CURRENCY_UNAVAILABLE` - Currency/plugin not available
- `NEGATIVE_AMOUNT` - Attempted negative transaction
- `PROVIDER_ERROR` - Economy plugin error
- `MAX_BALANCE_EXCEEDED` - Would exceed max balance

**Key Features:**
- Unified API for multiple economy plugins
- TransactionResult with detailed failure reasons
- Auto-detection of available economy plugins
- Custom currency registration
- String-based currency IDs for flexibility

### 27. Holograms (io.github.johnnypixelz.utilizer.hologram.Holograms)

The Holograms API provides a unified interface for creating floating text displays with automatic provider detection and click handling support.

```java
// Create a hologram with a specific ID
Hologram hologram = Holograms.create("my-hologram", location, List.of(
    "&6&lWELCOME",
    "&7to the server!",
    "&ewww.example.com"
));

// Create with varargs
Hologram shop = Holograms.create("shop", location, "&b&lSHOP", "&7Click to open");

// Create with auto-generated ID
Hologram temp = Holograms.create(location, "&aTemporary hologram");
String id = temp.getId();  // Get generated UUID

// Update hologram lines
hologram.updateLines(List.of("&6&lUPDATED", "&7New content!"));

// Teleport hologram
hologram.teleport(newLocation);

// Get hologram by ID
Hologram found = Holograms.get("my-hologram");
if (found != null) {
    Location loc = found.getLocation();
    List<String> lines = found.getLines();
}

// Check if hologram exists
if (Holograms.exists("my-hologram")) {
    // Do something
}

// Click handling (if supported by provider)
if (Holograms.supportsClickHandling()) {
    Holograms.onClick("shop", (player, hologramId, clickType) -> {
        switch (clickType) {
            case LEFT -> player.sendMessage("Left click!");
            case RIGHT -> player.sendMessage("Right click!");
            case SHIFT_LEFT -> player.sendMessage("Shift + left click!");
            case SHIFT_RIGHT -> player.sendMessage("Shift + right click!");
        }
    });
}

// Remove click handler
Holograms.removeClickHandler("shop");

// Remove hologram by ID
Holograms.remove("my-hologram");

// Or remove via hologram object
hologram.remove();

// Remove all holograms
Holograms.removeAll();

// Get count
int count = Holograms.count();

// Check provider status
boolean supported = Holograms.isSupported();
String providerName = Holograms.getProviderName();

// Plugin shutdown (cleanup)
Holograms.shutdown();
```

**Key Methods:**
- `Holograms.create(String id, Location, List<String>)` - Create hologram with ID
- `Holograms.create(String id, Location, String...)` - Create with varargs
- `Holograms.create(Location, List<String>)` - Create with auto-generated ID
- `Holograms.create(Location, String...)` - Create with auto ID and varargs
- `Holograms.get(String id)` - Get hologram by ID (nullable)
- `Holograms.exists(String id)` - Check if hologram exists
- `Holograms.remove(String id)` - Remove hologram by ID
- `Holograms.removeAll()` - Remove all holograms
- `Holograms.count()` - Get number of active holograms
- `Holograms.isSupported()` - Check if any provider is available
- `Holograms.getProviderName()` - Get active provider name
- `Holograms.shutdown()` - Cleanup on plugin disable

**Click Handling:**
- `Holograms.supportsClickHandling()` - Check if clicks are supported
- `Holograms.onClick(String id, HologramClickHandler)` - Set click handler
- `Holograms.removeClickHandler(String id)` - Remove click handler

**Hologram Interface:**
- `.updateLines(List<String>)` - Update displayed lines
- `.getLines()` - Get current lines
- `.getLocation()` - Get hologram location
- `.teleport(Location)` - Move hologram
- `.remove()` - Remove this hologram
- `.getId()` - Get hologram ID

**Click Types (HologramClickHandler.ClickType):**
- `LEFT` - Left mouse click
- `RIGHT` - Right mouse click
- `SHIFT_LEFT` - Left click while sneaking
- `SHIFT_RIGHT` - Right click while sneaking

**Supported Providers (auto-detected in priority order):**
1. **DecentHolograms** - Full click support
2. **HolographicDisplays** - Full click support
3. **FancyHolograms** - Full click support
4. **Native (TextDisplay)** - Built-in for 1.19.4+, full click support
5. **Native (ArmorStand)** - Fallback for older versions, full click support

**Key Features:**
- Unified API across all providers
- Automatic provider detection and fallback
- No external plugin required (native fallback)
- TextDisplay entities on 1.19.4+ for modern rendering
- ArmorStand entities on older versions
- Full click handling with all providers
- Color code support (use Colors.color() for hex colors)
- ID-based management for easy access
- Auto-generated UUIDs when ID not specified

## Best Practices

1. **Always extend io.github.johnnypixelz.utilizer.plugin.UtilPlugin**: This provides access to manager registration and lifecycle hooks.

2. **Use config.yml and messages.yml pattern**: Always separate settings from messages. Use `config.yml` for plugin settings and `messages.yml` for all player-facing messages. Load both on startup with `.watch()`.

3. **Use the io.github.johnnypixelz.utilizer.text.Messages system for all player communication**: Never hardcode messages in your code. Always use `Messages.cfg("messages", "path")` to pull from messages.yml for consistency and easy translation.

4. **Load configs on startup**: Call `Configs.load("configname").watch()` in your `onEnable()` method for all configs (except plugin.yml).

5. **Use io.github.johnnypixelz.utilizer.itemstack.Items.edit() for ItemStacks**: No clones are created - all modifications are direct. Use `getItem()` to get the reference.

6. **Use io.github.johnnypixelz.utilizer.tasks.Tasks for scheduling**: Replace Bukkit Scheduler with `Tasks.sync().delayed()`, `Tasks.sync().timer()`, etc. Methods accept Runnable directly.

7. **Use io.github.johnnypixelz.utilizer.plugin.Logs for logging**: Use `Logs.info()`, `Logs.warn()`, and `Logs.severe()` instead of accessing the plugin logger directly.

## Common Patterns

### Plugin Main Class
```java
public class MyPlugin extends UtilPlugin {

    @Override
    public void onEnable() {
        // ALWAYS load config.yml for settings and messages.yml for messages
        Configs.load("config").watch();
        Configs.load("messages").watch();

        // Load any additional data configs
        Configs.load("data").watch();

        // Register managers
        registerManager(new MyManager());

        // Register commands
        CommandManager.registerCommands(MyCommand.class);

        // Register custom placeholders
        registerPlaceholders();

        Logs.info("Plugin enabled!");
    }

    private void registerPlaceholders() {
        // Player-based placeholder: %example%
        Placeholders.register("example", player -> {
            return Configs.get("config")
                .getString("placeholders.example", "default");
        });

        // Static placeholder (no player needed): %my_server_stat%
        Placeholders.register("my_server_stat", () -> {
            return String.valueOf(getServerStat());
        });
    }

    @Override
    public void onDisable() {
        Logs.info("Plugin disabled!");
    }
}
```

### Config Structure Best Practice

**config.yml** - Plugin settings only:
```yaml
# Settings
max-players: 10
enable-pvp: true
cooldown-seconds: 30
reward-amount: "100-500"  # Uses Amount system

# Database settings
database:
  host: "localhost"
  port: 3306
  name: "mydb"
```

**messages.yml** - All player-facing messages:
```yaml
# Simple messages
welcome: "&aWelcome to the server!"
no-permission: "&cYou don't have permission!"

# Messages with placeholders
player-join: "&e%player% &7has joined the game!"

# Complex messages with titles, sounds, etc.
level-up:
  message: "&aYou leveled up to level %level%!"
  title: "&6&lLEVEL UP!"
  subtitle: "&eYou are now level %level%"
  actionbar: "&a+%xp% XP"
  sound: "ENTITY_PLAYER_LEVELUP"
  fade-in: 10
  stay: 70
  fade-out: 20
```

### Using Configs and Messages Together
```java
public class GameManager {
    
    public void startGame(Player player) {
        // Get settings from config.yml
        int maxPlayers = Configs.get("config").getInt("max-players");
        Amount rewardAmount = Amount.parse(Configs.get("config").getString("reward-amount"));
        
        // Send messages from messages.yml
        Messages.cfg("messages", "game.start")
            .map("%player%", player.getName())
            .map("%max%", String.valueOf(maxPlayers))
            .send(player);
        
        // Give reward
        int coins = rewardAmount.getAmount();
        Messages.cfg("messages", "reward.received")
            .map("%amount%", String.valueOf(coins))
            .send(player);
    }
    
    public void handleNoPermission(Player player) {
        // NEVER hardcode messages - always use messages.yml
        Messages.cfg("messages", "no-permission").send(player);
    }
}
```

### Using Items System
```java
// Create a custom item
ItemStack customSword = Items.edit(Material.DIAMOND_SWORD)
    .setDisplayName("&c&lFlame Blade")
    .setLore(
        "&7A sword forged in fire",
        "&7",
        "&eDamage: &c+12",
        "&eSpeed: &a+5%"
    )
    .addFlags(ItemFlag.HIDE_ENCHANTS)
    .glow()
    .setCustomModelData(1001)
    .getItem();

// Edit existing item
Items.edit(player.getInventory().getItemInMainHand())
    .setDisplayName("&aRenamed!")
    .setAmount(32)
    .addLore("&7Added lore line")
    .getItem();

// Use placeholders
Items.edit(rewardItem)
    .map("%player%", player.getName())
    .map("%amount%", "1000")
    .getItem();
```

### Using Tasks System
```java
// Delayed task
Tasks.sync().delayed(() -> {
    player.sendMessage("1 second has passed!");
}, 20L);  // Wait 1 second

// Repeating timer
Tasks.sync().timer(() -> {
    // This runs every second
    Bukkit.broadcastMessage("Tick!");
}, 20L);  // Every second

// Async task for heavy operations
Tasks.async().run(() -> {
    // Expensive calculation or I/O
    // Don't access Bukkit API here!
});

// Delayed timer (delay first, then repeat)
Tasks.sync().delayedTimer(() -> {
    player.sendMessage("Repeating message!");
}, 100L, 20L);  // Wait 5 seconds, then every 1 second

// Limited iterations
Tasks.sync().timed(() -> {
    player.sendMessage("This will show 3 times");
}, 20L, 3L);  // Every second, 3 times total
```

### Using Configs System
```java
// In onEnable - load all configs
Configs.load("config").watch();
Configs.load("messages").watch();

// Anywhere in your code - get config values
int maxPlayers = Configs.get("config").getInt("game.max-players");
String welcomeMsg = Configs.get("messages").getString("welcome");
List<String> rewards = Configs.get("config").getStringList("rewards.items");

// With defaults
double multiplier = Configs.get("config").getDouble("multiplier", 1.5);
```

### Using Messages System
```java
// Simple message from config
Messages.cfg("messages", "welcome").send(player);

// Message with placeholders
Messages.cfg("messages", "player.death")
    .map("%player%", player.getName())
    .map("%location%", location.toString())
    .send(player);

// Broadcast to everyone
Messages.cfg("messages", "server.restart").broadcast();

// Broadcast in range (50 blocks)
Point center = Point.of(event.getLocation());
Messages.cfg("messages", "area.event")
    .broadcast(center, 50.0);

// Complex message with title, sound, actionbar (from config)
Messages.cfg("messages", "achievements.unlock")
    .map("%achievement%", "Dragon Slayer")
    .map("%reward%", "1000 coins")
    .send(player);
// Config would have: message, title, subtitle, actionbar, sound, fade-in, stay, fade-out
```

## Package Structure

- `amount/` - Amounts system
- `bossbar/` - Bossbars system (Bossbars class)
- `command/` - Commands system
- `config/` - Configs system (Configs class)
- `cooldown/` - Cooldowns system
- `currency/` - Currencies system (Currencies class)
- `event/` - Event Emitters system
- `input/` - Chat Input system
- `inventory/` - Custom Inventories system
- `itemstack/` - Items system (Items class)
- `minigame/` - Minigames framework
- `plugin/` - Core plugin classes (UtilPlugin, Provider)
- `random/` - Random utilities
- `scoreboard/` - Scoreboards system (Scoreboards class)
- `serialize/` - Serialization & Deserialization
- `sql/` - SQL system
- `tasks/` - Tasks system (Tasks class)
- `text/` - Messages and text utilities

## Quick Reference

### Items
- `Items.edit(Material)` - Create new item
- `Items.edit(ItemStack)` - Edit existing item
- `.setDisplayName(String)` - Set display name (auto-colors)
- `.setLore(String...)` - Set lore lines (replaces existing)
- `.addLore(String...)` - Add lore lines (appends)
- `.setAmount(int)` - Set stack amount
- `.glow()` - Make item glow
- `.setGlow(boolean)` - Set glow state
- `.addFlags(ItemFlag...)` - Add item flags
- `.clearFlags()` - Remove all flags
- `.map(String, String)` - Replace placeholder in name/lore
- `.setCustomModelData(int)` - Set custom model data
- `.setDurability(int)` - Set durability
- `.meta(Consumer<ItemMeta>)` - Access ItemMeta
- `.getItem()` - Get ItemStack reference

### Tasks
- `Tasks.sync()` - Get synchronous scheduler
- `Tasks.async()` - Get asynchronous scheduler
- `.run(Runnable)` - Execute immediately
- `.delayed(Runnable, long)` - Execute after delay
- `.timer(Runnable, long)` - Repeat every X ticks
- `.delayedTimer(Runnable, long, long)` - Delay then repeat
- `.timed(Runnable, long, long)` - Repeat with iteration limit
- `.delayedTimed(Runnable, long, long, long)` - Delay, repeat with limit

### Configs
- `Configs.load(String)` - Load config file
- `.watch()` - Enable auto-reload
- `.save()` - Save config
- `.reload()` - Reload config
- `Configs.get(String)` - Get loaded config
- `.getString(String)` - Get string value
- `.getInt(String)` - Get integer value

### Messages
- `Messages.cfg(String, String)` - Get message from config
- `Messages.cfg(String)` - Get from "config" file (default)
- `.send(CommandSender)` - Send to player/console
- `.send(List)` - Send to multiple recipients
- `.broadcast()` - Send to all online players
- `.broadcast(Point, double)` - Broadcast in radius
- `.broadcast(Point, double, Predicate)` - Broadcast in radius with filter
- `.map(String, String)` - Replace placeholder
- `Messages.send(CommandSender, String)` - Send plain text
- `Messages.broadcast(String)` - Broadcast plain text

### Logs
- `Logs.info(String)` - Log info level message
- `Logs.warn(String)` - Log warning level message
- `Logs.severe(String)` - Log severe/error level message

### Amounts
- `Amount.of(int)` - Create static amount
- `Amount.range(int, int)` - Create dynamic range (min-max inclusive)
- `Amount.parse(String)` - Parse from string ("5" or "5-10")
- `.getAmount()` - Get value (static=fixed, dynamic=random)

### Parse
- `Parse.integer(String)` - Parse to Optional<Integer>
- `Parse.integer(String, int)` - Parse with default value
- `Parse.decimal(String)` - Parse to Optional<Double>
- `Parse.decimal(String, double)` - Parse with default value
- `Parse.color(String)` - Parse Bukkit Color from "r, g, b"
- `Parse.chatColor(String)` - Parse ChatColor from "r, g, b"
- `Parse.constrain(min, max, value)` - Clamp value to range (int/long/double/float)
- `Parse.stringOrList(section, path)` - Get List<String> from string or list

### Cooldowns
- `new Cooldown<T>()` - Create basic cooldown
- `new DynamicCooldown<T>()` - Cooldown with auto-cleanup and callbacks
- `new DynamicPlayerCooldown()` - Player cooldown (auto-removes on quit)
- `.set(T, long)` - Set cooldown in milliseconds
- `.add(T, long)` - Add time to existing cooldown
- `.remove(T)` - Remove from cooldown
- `.isOnCooldown(T)` - Check if on cooldown
- `.getCooldown(T)` - Get expiry timestamp
- `.setOnDone(Consumer<T>)` - Callback when expires (sync)
- `.setOnDoneAsync(Consumer<T>)` - Async callback when expires
- `.removeWithoutExecuting(T)` - Remove without triggering callback
- `.terminate()` - Stop background task (DynamicCooldown)

### Placeholders
- `Placeholders.set(Player, String)` - Process all placeholders (internal + PAPI)
- `Placeholders.set(OfflinePlayer, String)` - Process placeholders (static + PAPI for offline)
- `Placeholders.setStatic(String)` - Process only static placeholders (no PAPI)
- `Placeholders.register(String, Function<Player, String>)` - Register player placeholder
- `Placeholders.register(String, Supplier<String>)` - Register static placeholder
- `Placeholders.unregister(String)` - Unregister a placeholder
- `Placeholders.isRegistered(String)` - Check if placeholder exists
- Built-in: `%player%`, `%player_name%`, `%player_uuid%`, `%player_health%`, `%server_online%`, etc.
- Automatically processes PlaceholderAPI placeholders when PAPI is installed

### PlaceholderExpansion (PAPI)
- `PlaceholderExpansion.create()` - Create new expansion builder
- `.placeholder(String, Function<Player, String>)` - Simple placeholder
- `.placeholder(String, BiFunction<Player, PlaceholderArgs, String>)` - With template args
- `.relational(String, BiFunction<Player, Player, String>)` - Simple relational
- `.relational(String, TriFunction<Player, Player, PlaceholderArgs, String>)` - Relational with args
- `.register()` - Register with PlaceholderAPI
- Template patterns: `"stat_{type}"`, `"leaderboard_{skill}_top_{position}"`
- PlaceholderArgs: `.getString()`, `.getInt()`, `.getDouble()`, `.has()`, `.raw()`

### Dependencies (Plugin Hooks)
- `Dependencies.getVault()` - Get Vault wrapper (Optional)
- `Dependencies.isLoaded(String)` - Check if plugin is loaded
- `Dependencies.isEnabled(String)` - Check if plugin is enabled
- `Dependencies.getPlaceholderAPI()` - **Deprecated**, use PlaceholderExpansion

### Number Formatting
- `Numbers.toFormatted(long)` - Format with commas (e.g., "1,234,567")
- `Numbers.toRoundedFormatted(long)` - Round with suffixes (e.g., "1.5M", "5k")
- `Numbers.toRoman(int)` - Convert to Roman numerals (e.g., "XLII")

### Color Formatting
- `Colors.color(String)` - Parse `&` codes and hex colors (`&#RRGGBB`)
- `Colors.rgb(int, int, int)` - Create ChatColor from RGB values (0-255)

### Random Utilities
- `Randoms.pick(List<T>)` - Random element from list
- `Randoms.pick(T...)` - Random element from varargs
- `Randoms.weighted(Collection<Weighted<T>>)` - Weighted random selection
- `Randoms.chance(double)` - Returns true with probability 0.0-1.0
- `Randoms.percent(double)` - Returns true with percentage 0-100
- `Weighted.of(T, double)` - Create weighted item

### Scoreboards
- `Scoreboards.create(String)` - Create new scoreboard
- `Scoreboards.show(Player, Scoreboard)` - Show to player
- `Scoreboards.hide(Player)` - Hide from player
- `Scoreboards.update(Player)` - Update placeholders
- `Scoreboards.getFor(Player)` - Get player's scoreboard
- `Scoreboards.isShowing(Player)` - Check if showing
- `Scoreboards.shutdown()` - Shutdown service
- `.title(String)` - Set title
- `.line(int, String)` - Set line at index (0-14)
- `.lines(String...)` - Set multiple lines
- `.removeLine(int)` - Remove line
- `.clearLines()` - Clear all lines
- `.autoUpdate(long)` - Enable auto-refresh
- `.stopAutoUpdate()` - Stop auto-refresh

### Bossbars
- `Bossbars.create(String)` - Create new bossbar
- `Bossbars.create(String, BarColor)` - Create with color
- `Bossbars.create(String, BarColor, BarStyle)` - Create with color and style
- `Bossbars.show(Player, Bossbar)` - Show to player
- `Bossbars.hide(Player, Bossbar)` - Hide specific bossbar
- `Bossbars.hideAll(Player)` - Hide all from player
- `Bossbars.getFor(Player)` - Get player's bossbars
- `Bossbars.shutdown()` - Shutdown service
- `.title(String)` - Set title
- `.progress(double)` - Set progress (0.0-1.0)
- `.color(BarColor)` - Set color
- `.style(BarStyle)` - Set style
- `.addFlag(BarFlag)` - Add flag
- `.flags(BarFlag...)` - Set flags
- `.autoUpdate(long)` - Enable auto-refresh

### Currencies
- `Currencies.get(String)` - Get currency by ID (Optional)
- `Currencies.getAll()` - Get all currencies
- `Currencies.getAvailable()` - Get available currencies
- `Currencies.exists(String)` - Check if exists
- `Currencies.register(Currency)` - Register custom currency
- `Currencies.unregister(String)` - Unregister currency
- `Currencies.getBalance(String, OfflinePlayer)` - Get balance
- `Currencies.has(String, OfflinePlayer, double)` - Check has amount
- `Currencies.withdraw(String, OfflinePlayer, double)` - Withdraw (TransactionResult)
- `Currencies.deposit(String, OfflinePlayer, double)` - Deposit (TransactionResult)
- `Currencies.setBalance(String, OfflinePlayer, double)` - Set balance (TransactionResult)
- Currency IDs: `vault`, `playerpoints`, `coinsengine:<name>`, `tokenenchant`
- TransactionResult: `.success()`, `.reason()`, `.balanceBefore()`, `.balanceAfter()`

## Support

For issues, questions, or contributions, visit: https://github.com/JohnnyPixelz/Utilizer
